" Settings:
    set winaltkeys=no
    filetype plugin indent on
    syntax on

    behave mswin

    " changes from vim-sensible
    set ruler
    set showcmd
    set wildmenu
    set complete-=i
    set smarttab
    set nrformats-=octal
    set autoread
    set scrolloff=2
    set sidescrolloff=5
    set display+=lastline

    " enable backspacing over everything in indent mode
    set backspace=indent,eol,start

    " deal with line breaks
    set textwidth=80
    set formatoptions=cq
    set wrapmargin=0
    set linebreak

    " Replace tabs
    set tabstop=4
    set shiftwidth=4
    set expandtab

    " don't warn if an existing swap files is found
    set shortmess+=A

    " don't beep
    set visualbell
    set noerrorbells

    set undofile

    " Change backup file and undo file locations
    set directory=$DOTFILES/vim/swp//
    set backupdir=$DOTFILES/vim/backup//
    set undodir=$DOTFILES/vim/undo//

    " use views, but don't save options (which alters working directory)
    set viewdir=$DOTFILES/vim/view
    set viewoptions-=options

    " wrapped text should retain its indentation
    set breakindent
    " highlight wrapped lines
    let &breakindentopt='sbr'
    let &showbreak='| '

    " In many terminal emulators the mouse works just fine, thus enable it.
    if has('mouse')
      set mouse=a
    endif

    " fix insert mode navigation in Unix
    if has('unix')
        imap <Esc>OA <Up>
        imap <Esc>OB <Down>
        imap <Esc>OC <Right>
        imap <Esc>OD <Left>
        imap <80>K1 <Home>
        imap <80>K4 <End>
    endif

    " use unix line endings by default
    set fileformats=unix,dos
    set fileformat=unix

    " set diffexpr=MyDiff()

    " don't redraw unnecessarily
    set lazyredraw

    " always show status line
    set laststatus=2

    " bash on windows needs shellslash
    if has('win32') && (&shell =~ 'bash')
        set shellslash
    endif

" Functions:
    function MyDiff()
        let opt = '-a --binary '
        if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
        if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
        let arg1 = v:fname_in
        if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
        let arg2 = v:fname_new
        if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
        let arg3 = v:fname_out
        if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
        if $VIMRUNTIME =~ ' '
            if &sh =~ '\<cmd'
                if empty(&shellxquote)
                    let l:shxq_sav = ''
                    set shellxquote&
                endif
                let cmd = '"' . $VIMRUNTIME . '\diff"'
            else
                let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
            endif
        else
            let cmd = $VIMRUNTIME . '\diff'
        endif
        silent execute 'silent !' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
        if exists('l:shxq_sav')
            let &shellxquote=l:shxq_sav
        endif
    endfunction

    function CaptureEx(command)
        redir => output
        silent! execute a:command
        redir END
        return output
    endfunction

    function ReadEx(command)
        let output = CaptureEx(a:command)
        put=output
    endfunction

    function! SetVerbose(level) abort
        if a:level > 0
            " if we're doing verbose for the first time, clear the existing log
            if &verbosefile == ""
                silent! !rm $DOTFILES/vim/verbose.log
            endif
            set verbosefile=$DOTFILES/vim/verbose.log
        else
            let &verbosefile = ""
        endif
        execute "set verbose=" . a:level
    endfunction

    function! ProfileStart() abort
        profile start profile.log
        profile func *
        profile file *
    endfunction

    function! ProfileQuit() abort
        profile pause
        noautocmd qall!
    endfunction

" Commands:
    command! -nargs=1 SetVerbose call SetVerbose(<f-args>)
    command! ViewVerbose edit $DOTFILES/vim/verbose.log

    command! ProfileStart call ProfileStart()
    command! ProfileQuit call ProfileQuit()
