" Airline:
    let g:airline_theme="jam"
    let g:airline#extensions#branch#enabled=0

    " don't use separator symbols
    let g:airline_left_sep=''
    let g:airline_right_sep=''

    " skip crypt detection
    let g:airline_detect_crypt = 0

    " don't collapse, since we use different sections
    let g:airline_inactive_collapse = 0

    " load specific third party extensions rather than all of them
    let g:airline_extensions = ['ctrlp', 'syntastic', 'whitespace']

    if get(g:, 'eclim_loaded')
        call add(g:airline_extensions, 'eclim')
    endif

    " since we handle modified manually, don't autodetect it
    let g:airline_detect_modified=0

    function! ShortDirectoryName(dir)
        let dir = substitute(a:dir, '\v^.*epoc_([0-9]+\.[0-9]+)/(.*)', 'e\1 \2', '')
        let dir = substitute(dir, '\v^.*build_([0-9]+\.[0-9]+)/(.*)', 'a\1 \2', '')
        let dir = substitute(dir, '\va([0-9]+\.[0-9]+) perllib/Athena/(.*)', 'a\1/lib \2', '')
        let dir = substitute(dir, '\vp4/([^/]+)/?(.*)', '\1 \2', '')
        let dir = substitute(dir, '\v^.*/home/(Kevin|kejohnson)', '~', '')
        let dir = substitute(dir, '\v^.*[/\\]Users[/\\](Kevin|kejohnson)', '~~', '')
        let dir = substitute(dir, '\V\^' . expand('$DOTFILES') . '\[\\/]\?', 'dotfiles ', '')
        let dir = substitute(dir, '\v^dotfiles vim[\\/]bundle[\\/]', 'vlugins ', '')
        return dir
    endfunction

    function! AbbreviatePath(path)
        " convert a path into two-letter abbreviations
        " such as "/home/bob/bin" -> "/ho/bo/bi"
        let path_directories = split(a:path, '\v[/\\]', 1)
        let abbreviated_directories = []
        " for all directories except the last one
        for directory in path_directories[:-2]
            call add(abbreviated_directories, directory[:1])
        endfor
        " add the full last path
        call add(abbreviated_directories, path_directories[-1])
        let abbreviated_path = join(abbreviated_directories, '/')
        return abbreviated_path
    endfunction

    function! AirlineInit()
        " section a displays the relative path
        let g:airline_section_a = "%{airline#util#prepend(airline#parts#crypt(),0)}%{airline#util#prepend(airline#parts#paste(),0)}%{AbbreviatePath(ShortDirectoryName(expand('%')))}"
        " section b displays the absolute path to the current working directory
        let g:airline_section_b = '%{AbbreviatePath(ShortDirectoryName(getcwd()))}'
        " section c displays file tags, if available
        if get(g:, 'loaded_filesight', 0)
            let g:airline_section_c = '%{filesight#get_current_tag_name(1)} %#__accent_red#%m%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
        elseif get(g:, 'loaded_tagbar', 0)
            let g:airline_section_c = '%{airline#extensions#tagbar#currenttag()} %#__accent_red#%m%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
        else
            let g:airline_section_c = '%#__accent_red#%m%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
        endif
        " don't show column information
        let g:airline_section_x = '%3p%%%{g:airline_symbols.linenr}%#__accent_bold#%4l%#__restore__#'
        " let g:airline_section_z = '%{ShortDirectoryName(getcwd())}'
        let g:airline_section_y = ''
        let g:airline_section_z = ''
    endfunction
    autocmd User AirlineAfterInit call AirlineInit()

" Checkpoint:
    let g:checkpoint_directory = $DOTFILES . '/vim/checkpoints'

" Commentary:
    autocmd FileType jproperties setlocal commentstring=#\ %s

" CtrlP:
    let g:ctrlp_map = ';/'
    let g:ctrlp_working_path_mode = 'ra'
    " let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'
    let g:ctrlp_cmd = 'CtrlPMixed'
    let g:ctrlp_cache_dir = $HOME.'/vimfiles/cache/ctrlp'
    let g:ctrlp_user_command = 'es %s'
    " always open files in a new instance
    let g:ctrlp_switch_buffer = 0

" DBExt:
    " let g:dbext_default_usermaps = 0
    " let g:dbext_default_DBI_max_rows = 100
    " let g:dbext_strip_terminator = 1
    " let g:dbext_default_prompt_for_parameters = 0
    " nmap <silent> <Leader>sp vip<Plug>DBExecVisualSQL
    " nmap <silent> <Leader>sdt <Plug>DBDescribeTable

" Emotions:
    let g:emotions_create_ijkl_mappings = 1
    let g:emotions_create_word_mappings = 0
    let g:emotions_find_mapping_prefix = ''
    let g:emotions_ijkl_mapping_prefix = '<Leader>'

    let g:emotions_max_targets = 26

    " let g:emotions_target_highlight_group_primary = 'Identifier'
    " let g:emotions_target_highlight_group_secondary = 'Function'
    let g:emotions_highlight_type = 'conceal'

    let g:EasyMotion_leader_key = '~~~~'
    " let g:emotions_mapping_prefix = '~~'
    " let g:emotions_create_default_mappings = 0
    " let g:emotions_keys = 'qwertyuiopasdghklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNMfj;'
    " let g:emotions_force_uppercase = 1
    " let g:emotions_keys = 'uiojklm,.'
    " let g:emotions_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'
    " let g:emotions_keys = 'abcdefghijklmnopqrstuvwxyz;'
    " let g:emotions_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    " let g:emotions_keys = 'ASDFGQWERTZXCVBYNMPOIUHJKL'
    " let g:emotions_smartcase = 1
    " let g:emotions_use_smartsign_us = 1
    " let g:emotions_target_highlight_group = 'ErrorMsg'
    " let g:emotions_first_target_highlight_group = 'Comment'
    " let g:emotions_second_target_highlight_group = 'ErrorMsg'
    " hi link emotionsTargetGroup ErrorMsg
    " hi link emotionsFirstTargetGroup ErrorMsg
    " hi link emotionsSecondTargetGroup ErrorMsg
    " let g:emotions_space_jump_first = 1
    " let g:emotions_enter_jump_first = 1

" easy-align:
    nmap ga <Plug>(EasyAlign)v
    nmap <Leader>= <Plug>(EasyAlign)v
    nmap + <Plug>(EasyAlign)v
    " align latex tables
    nmap gat <Plug>(EasyAlign)vK*&

" Eclim:
    let g:EclimCompletionMethod = 'omnifunc'
    let g:EclimFileTypeValidate = 0
    let g:EclimMavenPomClasspathUpdate = 1
    let g:EclimProjectRefreshFiles = 1
    let g:EclimKeepLocalHistory = 0
    let g:EclimProjectTreeAutoOpen = 0

" Enchanted:
    " make sure vim is always very magic
    let g:VeryMagic=0
    let g:VeryMagicSubstitute=1
    let g:VeryMagicGlobal=0
    let g:VeryMagicVimGrep=1
    let g:VeryMagicSearchArg=1
    let g:VeryMagicFunction=1
    let g:VeryMagicHelpgrep=1
    let g:VeryMagicRange=1

" Fastfold:
    " don't pause on [] commands
      let g:fastfold_fold_movement_commands = []

" Filesight:
    " let g:filesight_file_types = ['html', 'vim', 'perl', 'python', 'tex', 'java']
    let g:filesight_ctags_extra_args = ['--tex-kinds=-l']
    let g:filesight_ctags_bin = expand("$USERPROFILE") . "/Utilities/ctags58/ctags.exe"
    let g:filesight_window_size = 30
    let g:filesight_run_on_startup = 0
    " let g:filesight_highlight_current_tag = "SpellRare"
    " let g:filesight_ctags_extra_args =
    "     \ '--regex-tex=//\\1/f,feat/e'
    let g:filesight_sort_tags = 'name'
    let g:filesight_use_conceal = 1

    let g:filesight_log_file_ctags = expand('$HOME/filesight_ctags.log')
    let g:filesight_log_file_debug = expand('$HOME/filesight_debug.log')

    let g:filesight_custom_tags = {
        \ 'perl': [
            \ {
                \ 'highlight': 'PreProc',
                \ 'name': 'pragma',
                \ 'short_name': 'G',
                \ 'position_after': 'package',
                \ 'tag_pattern': '^use ([a-z][a-zA-Z_:]+)',
                \ 'tag_output': '\\1',
            \ },
            \ {
                \ 'highlight': 'PreProc',
                \ 'name': 'import',
                \ 'position_after': 'pragma',
                \ 'tag_pattern': '^use ([A-Z][a-zA-Z_:]+)',
                \ 'tag_output': '\\1',
            \ },
        \ ],
        \ 'tex': [
            \ {
                \ 'highlight': 'Identifier',
                \ 'in_statusline': 0,
                \ 'name': 'table',
                \ 'short_name': 'T',
                \ 'tag_pattern': '^ +\\\\lcaption[{]([^}]+)[}]',
                \ 'tag_output' : '\\1',
            \ },
        \ ],
    \ }

" Fugitive:
    " commit changes to the current file
    command Gadd Git add "%"
    command! -nargs=1 GC silent! Git add "%" | execute "!git commit -m " . shellescape('<args>')

    " open git status the same way we open NerdTree
    " use 'u' for 'statUs'
    nnoremap ;u :Gstatus<CR>

" Go:
    let g:go_fmt_autosave = 0
    let g:go_dispatch_enabled = 1
    let g:go_textobj_enabled = 0
    let g:go_doc_keywordprg_enabled = 0


" Indent Object:
    let g:indent_object_no_mappings=1
    omap ai <Plug>IndentObject-ii
    omap aI <Plug>IndentObject-ii
    omap si <Plug>IndentObject-aI
    omap sI <Plug>IndentObject-ai

" Javascript:
    let javascript_enable_domhtmlcss = 1
    let javascript_fold = 0

" MatchTagAlways:
    let g:mta_filetypes = {
        \ 'html'  : 1,
        \ 'jsp'   : 1,
        \ 'xhtml' : 1,
        \ 'xml'   : 1,
        \ 'jinja' : 1,
    \ }

" Marvim:
    let marvim_store = $HOME . '/vimfiles/bundle/marvim/macros'
    let marvim_find_key = '<Leader>qf' " change find key from <F2> to 'space'
    let marvim_store_key = '<Leader>qs'     " change store key from <F3> to 'ms'
    let marvim_register = 'j'       " change used register from 'q' to 'c'
    " let marvim_prefix = 0           " disable default syntax based prefix

" Meta:
    let g:meta_directory = $DOTFILES . '/vim/meta'

" NERDTree:
    " don't automatically quit after opening a file
    let NERDTreeQuitOnOpen=0
    " disable 'press ? for help' text
    let NERDTreeMinimalUI=1
    " avoid confirmation for file manipulation
    let NERDTreeAutoDeleteBuffer=1
    " navigate directories easily
    let NERDTreeMapActivateNode="<CR>"
    let NERDTreeMapOpenRecursively="<S-CR>"
    let NERDTreeMapUpdirKeepOpen="j"
    let NERDTreeMapChangeRoot="l"
    let NERDTreeMapCloseDir="<Left>"
    let NERDTreeMapOpenRecursively="<Right>"
    " prevent remapping ik
    let NERDTreeMapOpenSplit="~"
    let NERDTreeMapJumpFirstChild="~~"
    let NERDTreeMapToggleHidden="H"

    let NERDTreeIgnore = ['\~$', '__pycache__', '__init__.py']
    " add the current file as a bookmark in NERDTree
    function! NTBookmark(bookmark_name, bookmark_type) abort
        if a:bookmark_type ==# "file"
            NERDTreeFind
        elseif a:bookmark_type ==# "dir"
            NERDTree
        else
            echoerr "Unable to recognize bookmark type '" + a:bookmark_type + "'"
        endif
        try
            execute "Bookmark " . a:bookmark_name
            NERDTreeClose
        catch /\VUndefined variable: nerdtree/
            NERDTreeClose
            redraw
            echomsg "A bookmark named '" . a:bookmark_name . "' already exists"
        endtry
    endfunction
    command! -nargs=1 NTBookmarkFile call NTBookmark(<f-args>, "file")
    command! -nargs=1 NTBookmarkDir call NTBookmark(<f-args>, "dir")

    " go to the given bookmark
    function! NTGoToBookmark(bookmark_name, bookmark_type) abort
        if a:bookmark_type ==# "file"
            NERDTree
            execute "OpenBookmark " . a:bookmark_name
            NERDTreeClose
        elseif a:bookmark_type ==# "dir"
            execute "NERDTreeFromBookmark " . a:bookmark_type
        else
            echoerr "Unable to recognize bookmark type '" + a:bookmark_type + "'"
        endif
    endfunction
    command! -nargs=1 NTGoToBookmarkFile call NTGoToBookmark(<f-args>, "file")

    " bookmark mappings
    nnoremap ;b :NERDTreeFromBookmark 
    nnoremap ;B :NTGoToBookmarkFile 
    nnoremap ;m :NTBookmarkFile 
    nnoremap ;M :NTBookmarkDir 

    " run a command in the current directory
    function! NTRun(command) abort
        let close_tree = 0
        if ! exists("b:NERDTree")
            NERDTree
            let close_tree = 1
        endif

        let path = b:NERDTree['root']['path']['str']()
        if &shellslash && has('win32')
            let path = substitute(path, '\', '\\', 'g')
        endif
        execute "! cd " . shellescape(path) . " && " . a:command
        if close_tree == 1
            NERDTreeClose
        endif
    endfunction
    command! -nargs=1 NTRun call NTRun(<f-args>)

    autocmd Filetype nerdtree nmap ! :NTRun 

" Repeat:
    " prevent mapping 'u'
    nmap :~~~~u <Plug>(RepeatUndo)
    nmap :~~~~U <Plug>(RepeatUndoLine)
    nmap :~~~~R <Plug>(RepeatRedo)

" Supertab:
    " let g:SuperTabDefaultCompletionType = "<c-x><c-u>"
    " let g:SuperTabDefaultCompletionType = "context"

" Surround:
    " mappings for vim surround
    let g:surround_no_mappings=1
    " delete
    nmap dh <Plug>Dsurround
    " create
    nmap ch <Plug>Ysurround
    " replace
    nmap rh <Plug>Csurround
    " delete
    " nmap ds <Plug>Dsurround
    " replace
    " nmap rs <Plug>Csurround
    " add surrounding
    " nmap <Leader>s <Plug>Ysurround
    " nmap <Leader>S <Plug>YSurround
    " nmap <Leader>ss <Plug>Yssurround
    " nmap <Leader>Ss <Plug>YSsurround
    " nmap <Leader>SS <Plug>YSSurround

" Perl Support:
    " tell perl-support not to override ctrl-j mapping
    let g:Perl_Ctrl_j='off'
    let g:Perl_LocaltemplateFile = $DOTFILES . "/vim/perl-support/templates/Templates"

" Pydiction:
    let g:pydiction_location = 'C:/Program Files/Vim/vimfiles/ftplugin/pydiction/complete-dict'
    let g:pydiction_menu_height = 10

" Syntastic:
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_check_on_open = 0
    let g:syntastic_enable_perl_checker = 1
    let g:syntastic_mode_map = {
        \ 'mode': 'passive',
    \ }
    let g:syntastic_css_checkers = ['csslint']
    let g:syntastic_css_csslint_args = "--ignore=ids,box-sizing"
    let g:syntastic_javascript_checkers = ['eslint']
    let g:syntastic_go_checkers = ['go']
    let g:syntastic_perl_checkers = ['perl']
    let g:syntastic_python_checkers = ['flake8']
    let g:syntastic_yaml_checkers = ['yamlxs']
    " check syntax ('help check')
    nnoremap hc :SyntasticCheck<CR>
    " check errors ('help errors')
    nnoremap he :Errors<CR>
    let g:syntastic_python_flake8_quiet_messages = {
        \ "level":  "warnings",
        \ "type":    "style",
        \ "regex":   'W503',
    \ }
    let g:syntastic_always_populate_loc_list = 1

" Tagbar:
    let g:tagbar_skip_ctags_validation = 1
    let g:tagbar_skip_update_on_save = 1
    let g:tagbar_skip_update_time_check = 1
    let g:tagbar_width = 30
    let g:tagbar_ctags_bin = expand("$USERPROFILE") . "/Utilities/ctags58/ctags.exe"
    let g:ctags_types = {'vim': 1, 'eiffel': 1, 'asm': 1, 'sh': 1, 'asp': 1, 'html': 1, 'basic': 1, 'rexx': 1, 'lisp': 1, 'c++': 1, 'cobol': 1, 'sql': 1, 'ant': 1, 'lua': 1, 'awk': 1, 'matlab': 1, 'tcl': 1, 'beta': 1, 'erlang': 1, 'python': 1, 'slang': 1, 'verilog': 1, 'c': 1, 'pascal': 1, 'tex': 1, 'vhdl': 1, 'vera': 1, 'php': 1, 'ocaml': 1, 'java': 1, 'flex': 1, 'scheme': 1, 'make': 1, 'sml': 1, 'c#': 1, 'perl': 1, 'dosbatch': 1, 'yacc': 1, 'javascript': 1, 'ruby': 1, 'fortran': 1}

    nnoremap <silent> hf :TagbarOpen fj<CR>
    let g:tagbar_sort = 1
    let g:tagbar_indent = 1
    let g:tagbar_compact = 1
    let g:tagbar_foldlevel = 2
    let g:tagbar_show_visibility = 0

" Ultisnips:
    let g:UltiSnipsSnippetsDir = $DOTFILES . '/vim/UltiSnips'
    " manually specify snippet directory for speed
    let g:UltiSnipsSnippetDirectories=[$DOTFILES . '/vim/UltiSnips']

" Vim Latex:
    let g:tex_flavor='latex'
    " grep will sometimes skip displaying the file name if you
    " search in a singe file. This will confuse Latex-Suite. Set your grep
    " program to always generate a file-name.
    set grepprg=grep\ -nH\ $*
    " Starting with Vim 7, the filetype of empty .tex files defaults to
    " 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
    " The following changes the default filetype back to 'tex':
    let g:tex_flavor='latex'
    " remove markers in vim latex
    let g:Imap_UsePlaceHolders = 0
    let g:Tex_DefaultTargetFormat = 'pdf'
    " prevent interference with c-j by mapping it to something
    " that shouldn't interfere
    map :~~~~ <Plug>IMAP_JumpForward
    imap :~~~~ <Plug>IMAP_JumpForward
    let g:Tex_Folding = 0

"YouCompleteMe

    highlight Pmenu ctermbg=black ctermfg=darkgreen
    highlight PmenuSel ctermbg=darkgray ctermfg=black

    " up and down should always go up and down, not control the menu
    let g:ycm_key_list_select_completion = ['<C-n>']
    let g:ycm_key_list_previous_completion = ['<C-p>']
    let g:SuperTabDefaultCompletionType = '<C-n>'

    " better key bindings for UltiSnipsExpandTrigger
    let g:UltiSnipsExpandTrigger = "<S-Enter>"
    let g:UltiSnipsJumpForwardTrigger = "<tab>"
    let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

    " don't eat CR?
    let g:SuperTabCrMapping = 0

    " force completion
    let g:ycm_key_invoke_completion = '<S-Enter>'
